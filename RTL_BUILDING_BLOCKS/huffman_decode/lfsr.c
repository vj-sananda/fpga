/* This program emulates an LFSR of up to 32 bits long.  Inputs are the register length, 	the number of taps, and the taps themselves.  If the LFSR is not of maximal length, 	there will be no output.  If it is of maximal length, the outputs are the tap sequence,	the period of the LFSR, and the elapsed time it took to cycle through the period.		Thanks to Jim B. and Les C. for their help. */#include <stdio.h>#include <math.h>#include <time.h> void shift(void);int ndega;					// shift register lengthunsigned long nrega;		// shift register contentsint ntapa;					// number to tapsunsigned long ivectora;		// init vectorint ntaparra[32];			// tapsunsigned long ntapbits[32];unsigned long mtapbits;inline int parity(unsigned long val){	int sum = 0;	unsigned long lsbval;	while (val != 0)	{		lsbval = val & -(long)val;		val &= ~lsbval;		sum++;	}	return (sum & 0x01);}inline void shift(void){	unsigned long nfeedback, ixsum;/* Initialize the tap value summer */	ixsum = 0;	/* The feedback bit is the XOR of the tapped bits or the modulo 2 of the	sum of their values */	ixsum = (unsigned long)parity(nrega & mtapbits);/* Move the feedback bit to the first bit */	nfeedback = ixsum << (ndega - 1);/* Shift the LFSR one place to the right and insert the feedback bit */	nrega = (nrega>>1) | nfeedback;}void main(void){	int i, j;	double cnt, f1;	time_t start_time, end_time;    /* Set input vector to any number less than 2^ndega and greater than zero */	ivectora = 1; 	/* Fetch register length  */	printf("Enter register length - ");	scanf(" %d", &ndega); /* Fetch number of taps  */	printf("Enter # of taps (dec) - ");	scanf(" %d", &ntapa); /* Loop through and get tap values */	printf("Enter taps \n"); 	for (i = 0; i < ntapa; i++){		printf("     ---> ");		scanf(" %d", &ntaparra[i]);	}/* Initialize shift register */	nrega = ivectora;/* Loop through and init the values of the bits pointed to by the taps */    mtapbits = 0;	for (i = 0; i < ntapa; i++){		mtapbits |=		ntapbits[i] = (0x01UL << (ndega-ntaparra[i]));	}/* Set the upper limit for the loop count; if the count reaches f1,	the sequence is maximal or it isn't even in correct form */	f1 = (float)pow(2.0, (double)ndega);/* Clock the shift register and compare its internal state to the 	initialization vector.  If it reaches the init vector, the loop	is closed.  If it doesn't repeat the init vector before it exceeds	the max count, the sequence was not in correct form */	start_time = time(NULL);	for (cnt = 1.0; cnt < f1; cnt++){		shift();/* Uncomment this statement to output the internal state of the LFSR		printf("\n %d", nrega); *//* If the internal state of the LFSR equals the init vector, print out	the tap sequence and the loop count.  A loop count = 2^ndega - 1	signifies a maximal length tap sequence */		if (nrega == ivectora){			end_time = time(NULL);			if (cnt >= (f1-1)){				printf("\n     Taps");				for (i = 0; i < ntapa; i++){					printf(" - %d", ntaparra[i]);				}				printf("\n     Repeat At - %10.0f\n", cnt);				printf("===============================\n");				printf("\nTime - %1.0f Seconds.\n", (double)(end_time - start_time));			}			break;		}	}/* Wait for user to read results */	printf("\nPress Return to End Program\n");	scanf("%*c%*[^\n]");}